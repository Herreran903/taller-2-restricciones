% !TEX root = ../../main.tex

\subsection{Análisis y conclusiones}\label{sec:01-jobshop_mantenimiento-analisis-y-conclusiones}

En el solver \texttt{Gecode}, la efectividad de las restricciones redundantes depende fuertemente de la estrategia de búsqueda aplicada. Con la heurística \texttt{first\_fail} (\texttt{ff\_min}), su inclusión no garantizó mejoras y en varios casos fue perjudicial. En ciertas instancias aumentaron el tiempo de ejecución, los nodos y los fallos; es decir, el costo adicional de propagación no siempre se compensó con una poda más efectiva del árbol de búsqueda. En contraste, con la heurística informada \texttt{dom\_w\_deg} (\texttt{wdeg\_split}) se observaron beneficios claros, en donde en general, los nodos y fallos disminuyeron y los tiempos mejoraron, especialmente en instancias complejas, aunque con excepciones puntuales como \texttt{test\_10}. Esta estrategia, al ponderar el grado de conflicto de las variables, aprovecha mejor la información adicional de las restricciones redundantes para priorizar ramas más prometedoras. Con la heurística simple \texttt{input\_order} (\texttt{inorder\_min}), el impacto fue neutro o negativo: en muchas ejecuciones se alcanzó el límite de tiempo sin mejoras, lo que sugiere que las redundantes añadieron carga computacional sin una poda apreciable.

El solver \texttt{Chuffed} mostró un comportamiento distinto y más robusto frente a las restricciones redundantes. Con \texttt{ff\_min}, estas no afectaron negativamente y en algunas instancias redujeron nodos y fallos, aunque el tiempo fue irregular. Con \texttt{wdeg\_split}, el efecto fue neutral o levemente positivo, manteniendo o mejorando el rendimiento en las instancias más exigentes gracias a podas tempranas propiciadas por la información redundante. Con \texttt{inorder\_min}, los resultados fueron mixtos. Algunas instancias mejoraron levemente y otras presentaron un aumento marginal en el tiempo. Esto evidencia que \texttt{Chuffed} tolera mejor la sobrecarga de las redundantes que \texttt{Gecode}, sufriendo menos degradación en desempeño.

En síntesis, las restricciones redundantes R4 y R5 no son ventajosas de forma global, en donde su impacto depende de la heurística de búsqueda y del solver. Las estrategias informadas, como \texttt{wdeg\_split}, pueden aprovechar la información extra para mejorar la poda del espacio de búsqueda, mientras que con heurísticas simples la sobrecarga de propagación suele superar los beneficios. Destaca que \texttt{Chuffed} logra beneficiarse, o al menos no verse penalizado, por las redundantes en un rango más amplio de configuraciones, especialmente en las de mayor complejidad.

De manera global, la combinación \texttt{Chuffed + wdeg\_split} resultó la más eficiente. Esta heurística, que prioriza variables con dominios pequeños y alto grado de conflicto, permite una poda temprana del árbol de búsqueda y una reducción sustancial en nodos y fallos. Bajo esta configuración, las restricciones redundantes fueron especialmente útiles, ya que \texttt{Chuffed} aprovechó la información adicional sin incurrir en sobrecostos significativos. En contraste, las estrategias más simples (\texttt{ff\_min} e \texttt{inorder\_min}) mostraron comportamientos más variables y, en el caso de \texttt{Gecode}, incluso contraproducentes, pues el esfuerzo de propagación superó los beneficios en la poda.

Comparando los solvers, \texttt{Chuffed} fue más rápido y eficiente que \texttt{Gecode} en la mayoría de los escenarios. Esta ventaja fue más evidente con heurísticas menos informadas, donde \texttt{Gecode} alcanzó el límite de tiempo con frecuencia. Su arquitectura, basada en \textit{lazy clause generation}, le permite una propagación más inteligente y un mejor aprovechamiento de las redundantes, alcanzando soluciones óptimas con menos esfuerzo. En las instancias más grandes, \texttt{Chuffed} resolvió y verificó óptimos con un costo sustancialmente menor.

Respecto a la restricción de simetría (R6), se evaluaron ejecuciones con y sin dicha restricción, manteniendo activas las redundantes, en las instancias \texttt{test\_01} y \texttt{test\_02} con trabajos idénticos. En optimización, R6 resultó claramente beneficiosa, especialmente en \texttt{test\_02}. En \texttt{Gecode}, redujo de forma consistente los nodos y fallos, con mejoras notables en tiempo (aproximadamente a la mitad). En \texttt{Chuffed}, el efecto fue aún mayor: con \texttt{ff\_min}, el tiempo bajó de $\sim$35 ms a $\sim$8 ms, y con \texttt{wdeg\_split} de $\sim$10 ms a $\sim$4 ms, acompañándose de reducciones significativas en nodos y fallos.

Para cuantificar el efecto de R6, se realizaron pruebas en modo \texttt{satisfy} para enumerar todas las soluciones, comparando configuraciones con y sin simetría. Aunque la mayoría no completó la enumeración antes del límite de 60 s, en todos los casos el número de soluciones distintas fue ligeramente menor con la simetría activa. La reducción no fue drástica, pero confirma que R6 elimina correctamente soluciones equivalentes por permutación de trabajos idénticos.

En conclusión, la restricción de simetría R6 es una adición útil para instancias con trabajos idénticos, en donde reduce caminos de búsqueda equivalentes, disminuye la redundancia de soluciones y acelera la búsqueda de óptimos. Aunque su impacto en la enumeración completa es moderado, aporta un beneficio sin efectos adversos, por lo que se recomienda incluirla cuando existan trabajos indistinguibles.

